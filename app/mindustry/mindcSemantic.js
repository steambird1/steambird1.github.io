import { ASTNodeType, AttributeClass, ASTNode, CompilationPhase,
	VariableDeclarationNode, CastExpression, ConditionalExpressionNode, NumericLiteralNode, StringLiteralNode,
	CharacterLiteralNode, NullLiteralNode, ASTVisitor, __convert, objectList,
	liquidList, unitList, buildingList
 } from "./mindcBase.js";

// 修改SymbolEntry类以存储更详细的类型信息
/**
 * @member {boolean} accessThroughPointer Indicating whether the variable should be accessed by a memory address (not necessarily be a pointer!)
 * @member {boolean} implementAsPointer Indicating whether the variable IS a pointer (or array, which is regarded as a pointer.)
 * @member {boolean} needMemoryAllocation
 */
export class SymbolEntry {
	/**
	 * 
	 * @param {string} name 
	 * @param {TypeInfo | string | {returnType: string, parameters: {name: string, type: string}[]}} type 
	 * @param {Scope | null} scope 
	 * @param {string} kind 
	 * @param {*} location 
	 * @param {number} size 
	 */
    constructor(name, type, scope, kind, location = null, size = null) {
        this.name = name;
        this.type = type; // 类型信息（现在是TypeInfo对象）
		this.size = size;	// Should be generated by compiler system
        this.scope = scope;
		this.owningScope = null;	// The scope that the function (if it points to one) owns
        this.kind = kind; // 'variable', 'function', 'parameter', 'type'
        this.location = location;
        this.initialized = false;
        this.used = false;
		// Unused:
		this.readCount = 0; // 读取次数
        this.writeCount = 0; // 写入次数
		// Unused end

        this.memoryLocation = null;
		this.accessThroughPointer = false;	// In-memory variable, must be accessed through memory blocks
											// THIS ALSO MEANS THAT: you can and should always dereference it to get the real value
		this.implementAsPointer = (this.type && (this.type.kind === 'pointer' || this.type.kind === 'array'));
											// This is true will mean that when getting value, it will return a pointer
											// ACCORDING TO THAT DEFINITION, struct SHOULD BE "IMPLEMENTED AS POINTER"
											// instead of "ACCESS THROUGH POINTER"
		this.needMemoryAllocation = false;

		this.isAutoDevice = false;
		this.isVirtualSymbol = false;
		this.isRecursiveSymbol = false;
		// (for struct, union, pointer and array)

        this.isGlobal = false;
		this.isRegister = false; // 标记是否为register变量
		this.isStatic = false;
		this.isExtern = false;
		// Note: this is also available for functions:
		// (for functions, once 'true', it can't be inlined !)
        this.isAddressed = false; // 标记是否被取地址
		this.isConst = false;
        this.isVolatile = false;
		// 常量传播相关
        this.isConstant = false;
        this.constantValue = null;

		// Used for code generator
		this.isNearPointer = false;
        
        // 优化标记 [Not really used right away]
        this.canBeEliminated = false;
        this.isDead = false;
    }
	
	// 标记为常量
    markAsConstant(value) {
        this.isConstant = true;
        this.constantValue = value;
		let typeRef = this.myType();
        if (typeRef && typeRef.qualifiers) {
            typeRef.qualifiers.push('const');
        }
    }

	/**
	 * 
	 * @returns {TypeInfo}
	 */
	myType() {
		if (!this.type) return null;
		return this.type.type ? this.type.type : this.type;
	}

	isStructOrUnion() {
		if (!this.type) return false;
		const curType = this.myType();
		return curType.kind === 'struct' || curType.kind === 'union';
	}

	isBasic() {
		const curType = this.myType();
		return curType && curType.kind === 'basic';
	}

	isPointer() {
		return this.accessThroughPointer || this.implementAsPointer || this.needMemoryAllocation;
	}

	/**
	 * In current version, a structure can't be regarded as `accessThroughPointer`.
	 * @returns {boolean}
	 */
	isRegistryStruct() {
		return this.isStructOrUnion() && !this.isPointer();
	}

	getAssemblySymbol() {
		if (this.isAutoDevice) {
			return this.name;
		}
		if (this.kind === 'function') {
			return '_' + this.name;
		}
		if (this.scope) {
			return this.scope.getPath() + "." + this.name;
		} else {
			return this.name;
		}
	}

	duplicate() {
		let result = new SymbolEntry(this.name, this.type, this.scope, this.kind);
		Object.assign(result, this);
		return result;
	}

	/**
	 * 
	 * @returns {TypeInfo}
	 * @throws
	 */
	extractType() {
		/**
		 * @type {TypeInfo}
		 */
		let resultType = this.myType().duplicate();
		if (this.isAutoDevice) resultType.qualifiers.push('auto');
		if (this.isRegister) resultType.qualifiers.push('register');
		if (this.isConst || this.type.isConst) resultType.qualifiers.push('const');
		if (this.isVolatile || this.type.isVolatile) resultType.qualifiers.push('volatile');
		if (this.isExtern) resultType.qualifiers.push('extern');
		if (this.isStatic) resultType.qualifiers.push('static');
		return resultType;
	}

	describe() {
		return `${this.name}: ${
			(typeof this.type === 'object') ? this.extractType().toString() : `#${this.type}`} @ ${this.scope ? this.scope.getPath() : 'g'}`;
	}
}

// 作用域类
export class Scope {
    constructor(parent = null, type = 'b', astNode = null, name = '') {
        this.parent = parent;
        this.type = type; // g 'global', f 'function', b 'block'
		this.name = name;
		this.astNode = astNode; // 关联的AST节点
        this.symbols = new Map();
        this.children = [];
		
		if (parent) {
            parent.children.push(this);
        }
    }

    addSymbol(symbol) {
        this.symbols.set(symbol.name, symbol);
		symbol.scope = this; // 建立双向关联
    }
	
	removeSymbol(name) {
		this.symbols.delete(name);
	}

	/**
	 * 
	 * @param {string} name 
	 * @returns {SymbolEntry | null}
	 */
    lookup(name) {
        return this.symbols.get(name) || (this.parent ? this.parent.lookup(name) : null);
    }
	
	/**
	 * 
	 * @param {string} name 
	 * @returns {Scope | null}
	 */
	lookupScopeOf(name) {
		if (this.symbols.has(name)) {
			return this;
		}
		const result = this.parent ? this.parent.lookupScopeOf(name) : null;
		return result;
	}

    lookupCurrent(name) {
        return this.symbols.get(name) || null;
    }
	
	// 获取当前作用域的所有符号
	/**
	 * @returns {SymbolEntry[]} All symbols of current scope.
	 * @remark Notice: children scopes' information isn't included.
	 */
    getAllSymbols() {
        return Array.from(this.symbols.values());
    }

	/**
	 * @returns {SymbolEntry[]}
	 */
	recursivelyGetAllSymbols() {
		return [...this.getAllSymbols(), ...(this.children.flatMap(child => child.recursivelyGetAllSymbols())) ];
	}
	
	// 获取作用域的完整路径
    getPath() {
        const path = [];
        let current = this;
        while (current) {
            path.unshift(current.type + ':' + current.name);
            current = current.parent;
        }
        return path.join('.');
    }
}

// 首先，添加一些辅助类
export class TypeInfo {
	/**
	 * 
	 * @param {string} name 
	 * @param {string} kind 
	 * @param {number} size 
	 * @param {any[] | null} members 
	 */
    constructor(name, kind, size = 1, members = null) {
        this.name = name; // 类型名称
        this.kind = kind; // 'basic', 'struct', 'union', 'pointer', 'array', 'function', 'device', 'null'
        this.size = size; // 类型大小（按1字节对齐）
        this.members = members || []; // 结构体/联合体成员
        this.pointerTo = null; // 对于指针类型，指向的类型 (MUST BE A TYPE, NOT A FUNCTION)
        this.arraySize = null; // 对于数组类型，数组大小
        this.qualifiers = []; // 类型限定符: const, volatile, auto, register, extern, etc.
		// Probably we consider 'near' and 'far' as well
		this.functionTo = null;	// Pointing to what function for function type
		this.memberReference = null;
    }
    
    isConst() {
        return this.qualifiers.includes('const');
    }
    
    isVolatile() {
        return this.qualifiers.includes('volatile');
    }

	isExtern() {
		return this.qualifiers.includes('extern');
	}

	isNear() {
		return this.qualifiers.includes('near');
	}

	isStrictPointerImpl() {
		const pointerImplementation = ['pointer', 'array'];
		return ((typeof this.kind === 'object') && this.kind.isStrictPointerImpl()) ||
		 pointerImplementation.includes(this.kind);
	}

	isPointerImpl() {
		const pointerImplementation = ['pointer', 'array'];
		if (this.kind === 'struct' || this.kind === 'union') {
			return this.isVolatile() || this.isStrictPointerImpl();
		}
		return ((typeof this.kind === 'object') && this.kind.isPointerImpl()) ||
		 pointerImplementation.includes(this.kind) || this.isVolatile();
	}

	isRegStruct() {
		return (this.kind === 'struct' || this.kind === 'union') && !this.isPointerImpl();
	}

	initializeReferenceTable() {
		this.memberReference = new Map();	// Used only in generation
		this.members.forEach(member => {
			this.memberReference.set(member.name, member.offset);
		});
	}	
    
    toString() {
        let result = this.qualifiers.length > 0 ? this.qualifiers.join(' ') + ' ' : '';
        result += this.name;
        if ((this.kind === 'pointer' || this.kind === 'array') && this.pointerTo) {
            result += this.pointerTo.toString() + '*';
        }
		if (this.type === 'array') {
			result += `[${this.arraySize ?? ''}]`;
		}
		if (this.kind === 'function') {
			result += '{' + this.functionTo.type.returnType.toString() + ' || ';
			result += (this.functionTo.type.parameters.map(param => (param.type.toString()))).join(',') + '}';
		}
        return result;
    }

	/**
	 * @remark Shallow copy for members and comprehensive copy for qualifiers.
	 * @returns {TypeInfo}
	 */
	duplicate() {
		let result = new TypeInfo(this.name, this.kind, this.size);
		Object.assign(result, this);
		result.qualifiers = [...this.qualifiers];
		return result;
	}
}

export class MemberInfo {
	/**
	 * 
	 * @param {string} name 
	 * @param {TypeInfo} type 
	 * @param {number} offset 
	 * @param {null} bitField 
	 */
    constructor(name, type, offset, bitField = null) {
        this.name = name;
        this.type = type;
        this.offset = offset; // 成员偏移量
        this.bitField = bitField; // 位域信息 [Unused!!]
    }
}

export class SemanticAnalyzer extends ASTVisitor {
	// !! Global scope is being manually established !!
	/**
	 * 
	 * @param {Compiler} compiler 
	 */
    constructor(compiler = null) {
        super(compiler);
        this.errors = [];
        this.warnings = [];
        this.currentScope = null;
        this.currentFunction = null;
        this.symbolTable = new Map();
        this.typeTable = new Map();
        this.structTable = new Map(); // 专门存储结构体/联合体定义
        this.typedefTable = new Map(); // 存储typedef定义的类型别名
        
		this.targetVersion = this.compiler ? this.compiler.config.getAttribute('targetVersion') : 0;

		this.globalScope = null;	// ???
		this.scopeCounter = 0;
		this.virtualCounter = 0;
		// Cannot do initialization in construction !!!
    }

    analyze(ast) {
        this.errors = [];
        this.warnings = [];
        this.currentScope = new Scope(null, 'g');
        this.currentFunction = null;
		this.globalScope = this.currentScope;
		
		// 初始化内建类型
        this.initializeBuiltinTypes();
        this.initializeBuiltinFunctions();
		
		// 建立AST节点和作用域的关联
        this.linkScopesToAST(ast);
		
		// 第一遍：收集类型定义（typedef, struct, union）
        this.collectTypeDefinitions(ast);

        this.visit(ast);

        return {
            success: this.errors.length === 0,
            ast: ast,
            errors: this.errors,
            warnings: this.warnings,
            symbolTable: this.symbolTable
        };
    }
	
	// !! Notice: new scopes can't be created afterwards !!
	// 建立AST节点和作用域的关联
    linkScopesToAST(node) {
        if (!node) return;
        
        // 将当前作用域关联到节点
        node.scope = this.currentScope;
        
        switch (node.type) {
            case 'Program':
                // 程序节点关联全局作用域
                node.scope = this.globalScope;
                this.globalScope.astNode = node;
				// This is the actual thing...
				if (node.functions) {
					node.functions.forEach(child => this.linkScopesToAST(child));
				}
                break;
                
            case 'FunctionDeclaration':
                // 函数作用域
                const functionScope = new Scope(this.currentScope, 'f', node, node.name);
                this.currentScope = functionScope;
                node.scope = functionScope;
                break;
                
            case 'CompoundStatement':
                // 块作用域
				// TODO: There are some bugs here...
                if (this.currentScope.type !== 'f' || 
                    (this.currentScope.astNode && this.currentScope.astNode.type !== 'CompoundStatement')) {
                    const blockScope = new Scope(this.currentScope, 'b', node, '' + (++this.scopeCounter));
                    this.currentScope = blockScope;
                    node.scope = blockScope;
                } else {
                    // 函数体的第一个复合语句不创建新作用域
                    node.scope = this.currentScope;
                }
				if (node.statements) {
					node.statements.forEach(child => this.linkScopesToAST(child));
				}
                break;
        }
        
        // 递归处理子节点
        if (node.children) {
            node.children.forEach(child => this.linkScopesToAST(child));
        }

		const fieldsToCheck = [
				'functions', 'globalDeclarations', 'typeDefinitions',
				'statements', 'expression', 'test', 'consequent', 'alternate',
				'body', 'init', 'update', 'argument', 'left', 'right',
				'declarators', 'arguments', 'callee', 'initializer'
			];

			for (const field of fieldsToCheck) {
				if (Array.isArray(node[field])) {
					node[field].forEach(elem => this.linkScopesToAST(elem));
				} else if (node[field] && typeof node[field] === 'object') {
					this.linkScopesToAST(node[field]);
				}
			}
        
        // 退出作用域
        switch (node.type) {
            case 'FunctionDeclaration':
            case 'CompoundStatement':
                if (node.scope && node.scope !== this.globalScope) {
                    this.currentScope = node.scope.parent;
                }
                break;
        }
    }
	
	// !! MANUAL CHANGES HERE !!
	collectTypeDefinitions(node) {
        if (!node) return;
        
        // 收集程序中的类型定义
        if (node.type === 'Program') {
            // 收集typedef定义
			// Modified here
            if (node.typeDefinitions) {
                node.typeDefinitions.forEach(def => {
                    if (def.type === 'struct' || def.type === 'union') {
                        this.processStructOrUnionDefinition(def);
                    } else {
						if ((!def.isStruct) && (!def.isUnion)) {
							this.processTypedefDeclaration(def);
						}
						else {
							this.addError(`Internal error: Unknown parsed structure`, node.location);
						}
					}
                });
            }
            
            // 收集全局结构体/联合体定义
            node.globalDeclarations.forEach(decl => {
                if ((decl.type === 'VariableDeclaration' || decl.declarators) && decl.getAttribute('isStructOrUnion')) {
                    // 处理结构体/联合体变量声明中的类型定义
                    //this.processTypeFromDeclaration(decl.type);
					// 检查是否是结构体/联合体类型
					const typeName = this.getTypeNameFromTypeNode(decl.type);
					if (typeName === 'struct' || typeName === 'union') {
						// I don't know, but I guess this means that this type is still not
						// initialized.
						this.processTypeFromDeclaration(decl.type);
					}
				}
            });
        }
    }

    initializeBuiltinTypes() {
        // 基本类型
        const basicTypes = ['int', 'char', 'float', 'double', 'void', 'long', 'short', 'signed', 'unsigned', 'bool'];
        basicTypes.forEach(type => {
            this.typeTable.set(type, new TypeInfo(type, 'basic', 1));
        });

        // 特殊类型
        this.typeTable.set('device', new TypeInfo('device', 'device', 1));
        this.typeTable.set('null_t', new TypeInfo('null_t', 'null', 1));
		this.typeTable.set('content_t', new TypeInfo('content_t', 'device', 1));	// Similar to device
        // 'item_t', 'liquid_t', 'unit_t', 'block_t'
		for (const contentTypes of ['item_t', 'liquid_t', 'unit_t', 'block_t']) {
			this.typeTable.set(contentTypes, new TypeInfo(contentTypes, 'basic', 1));
		}

		const extraTypes = this.extraConfig.getAttribute('extraTypes');
		if (extraTypes) {
			extraTypes.forEach(
				/**
				 * @param {TypeInfo} type 
				 */
				type => {
					this.typeTable.set(type.name, type);
			});
		}

        // 指针类型的基础（void*）
		// Pointer has a size of 2 !!
		/*
        const voidPtrType = new TypeInfo('void*', 'pointer', 2);
        voidPtrType.pointerTo = this.typeTable.get('void');
        this.typeTable.set('void*', voidPtrType);
		const charPtrType = new TypeInfo('char*', 'pointer', 2);
        voidPtrType.pointerTo = this.typeTable.get('char');
        this.typeTable.set('char*', charPtrType);
		*/
    }

    initializeBuiltinFunctions() {
		// TODO: Must be modified...
		// TODO: Use boolean here
        const builtins = [
            { name: 'draw', returnType: 'void', parameters: ['char'], hasVarArgs: true }, // 操作名称 + 变长参数 (Actually, need further judgment)
			{ name: 'print', returnType: 'void', parameters: [], hasVarArgs: true }, // 变长参数 (Actually, accepting multiple operations)
			{ name: 'printchar', returnType: 'void', parameters: [], hasVarArgs: true }, 
			{ name: 'format', returnType: 'void', parameters: [], hasVarArgs: true }, 
			{ name: 'drawflush', returnType: 'void', parameters: ['device'] },
			{ name: 'printflush', returnType: 'void', parameters: ['device'] },
			{ name: 'getlink', returnType: 'device', parameters: ['int'] },
			{ name: 'control', returnType: 'void', parameters: ['char', 'device'], hasVarArgs: true }, // 操作名称 + 设备 + 变长参数
			{ name: 'radar', returnType: 'device', parameters: ['char', 'char', 'char', 'char', 'device', 'int'] },
			{ name: 'sensor', returnType: 'null_t', parameters: ['device', 'content_t'] },	// Sensor may return ANY TYPE. PROCESS ON YOUR OWN
			{ name: 'set', returnType: 'void', parameters: [], hasVarArgs: true, special: 'set' }, // 特殊处理
			{ name: 'op', returnType: 'void', parameters: [], hasVarArgs: true, special: 'op' }, // 特殊处理
			{ name: 'lookup', returnType: 'content_t', parameters: ['char', 'int'] },
			{ name: 'wait', returnType: 'void', parameters: ['float'] },
			{ name: 'stop', returnType: 'void', parameters: [] },
			{ name: 'end', returnType: 'void', parameters: [] },
			{ name: 'jump', returnType: 'void', parameters: [], hasVarArgs: true, special: 'jump' }, // 特殊处理
			{ name: 'read', returnType: 'void', parameters: [], special: 'read'}, // 特殊处理
			{ name: 'write', returnType: 'void', parameters: [], special: 'write'}, // 特殊处理
			{ name: 'ubind', returnType: 'void', parameters: ['content_t']},
			{ name: 'ucontrol', returnType: 'void', parameters: [], hasVarArgs: true},
			{ name: 'uradar', returnType: 'device', parameters: ['char', 'char', 'char', 'char', 'int', 'int'] },
			{ name: 'ulocate', returnType: 'int', parameters: [], hasVarArgs: true},
			{ name: 'asm', returnType: 'null_t', parameters: ['char'], special: 'asm'}, // TODO: I'm unsure about whether this can be correctly done now.
			{ name: 'sin', returnType: 'float', parameters: ['float'] },	// These are in [op] instruction
			{ name: 'cos', returnType: 'float', parameters: ['float'] },
			{ name: 'tan', returnType: 'float', parameters: ['float'] },
			{ name: 'asin', returnType: 'float', parameters: ['float'] },
			{ name: 'acos', returnType: 'float', parameters: ['float'] },
			{ name: 'atan', returnType: 'float', parameters: ['float'] },
			{ name: 'adiff', returnType: 'float', parameters: ['float', 'float'] },
			{ name: 'min', returnType: 'float', parameters: ['float', 'float'] },
			{ name: 'max', returnType: 'float', parameters: ['float', 'float'] },
			{ name: 'ceil', returnType: 'float', parameters: ['float']},
			{ name: 'floor', returnType: 'float', parameters: ['float']},
			{ name: 'sqrt', returnType: 'float', parameters: ['float']},
			{ name: 'abs', returnType: 'float', parameters: ['float']},
			{ name: 'rand', returnType: 'float', parameters: []},
			{ name: 'memcpy', returnType: 'void', parameters: ['void*', 'void*', 'unsigned']},
			{ name: 'memsp', returnType: 'void*', parameters: ['device', 'int']},
			...(this.extraConfig.getAttribute('extraFunctions') ?? [])
		];

        builtins.forEach(func => {
            const symbol = new SymbolEntry(
                func.name,
                { returnType: func.returnType, parameters: func.parameters, hasVarArgs: func.hasVarArgs ?? false, special: func.special ?? null },
                this.currentScope,
                'function'
            );
			// Builtin symbol doesn't own scope
            this.currentScope.addSymbol(symbol);
        });
    }

	// Deepseek has some branches here
	// ! There has some manual changes !
	processTypedefDeclaration(typedefNode) {
		// Deepseek says yes
		// 临时解决方案：检查节点是否具有declarators属性
		if (!typedefNode.declarators) {
			this.addError(`Internal Error: Invalid typedef declaration`, typedefNode.location);
			return;
		}
		
		// Some special process for function pointer type:
		// ! TODO: Functions will need 'isAddressed' (to suppress inlining) !
		if (typedefNode.isFunction) {
			typedefNode.declarators.forEach(declarator => {
				const aliasName = declarator.name;
				// Directly create a new type instead of go aliases
				// TODO: Add temporary name, if necessary?
				// Function has a size of 1 (its address)
				// (Different from pointer's size 2 due to the need of storing its block position
				// This will make them have a name
				const aliasType = new TypeInfo(aliasName, 'function', 1);
				aliasType.qualifiers = typedefNode.functionDefinition.pointerQualifiers;
				aliasType.functionTo = new SymbolEntry(
					aliasName,
					{
						returnType: typedefNode.functionDefinition.returnType.typeName,
						parameters: typedefNode.functionDefinition.parameters.map(param => ({
							name: param.name,
							type: this.getTypeNameFromTypeNode(param.type)
						}))
					},
					this.globalScope,
					'function',
					typedefNode.location
				);
				
				this.typeTable.set(aliasName, aliasType);
				this.typedefTable.set(aliasName, {
					originalType: aliasType,
					aliasType: aliasType,
					location: declarator.location
				});
			});
		} else {
			// Traditional process
			let baseTypeName = this.getTypeNameFromTypeNode(typedefNode.type);
			let baseType = this.getTypeInfo(baseTypeName);
			
			if (!baseType) {
				this.addError(`Unknown base type '${baseTypeName}' in typedef`, typedefNode.location);
				return;
			}
			
			typedefNode.declarators.forEach(declarator => {
				const aliasName = declarator.name;
				const aliasType = this.createAliasType(baseType, declarator);
				
				// 添加到类型表和typedef表
				this.typeTable.set(aliasName, aliasType);
				this.typedefTable.set(aliasName, {
					originalType: baseType,
					aliasType: aliasType,
					location: declarator.location
				});
			});
		}
    }
	
	processStructOrUnionDefinition(defNode) {
        const typeName = defNode.name || `anonymous_${defNode.type}_${Date.now()}`;
        const isUnion = defNode.type === 'UnionDefinition';
        const kind = isUnion ? 'union' : 'struct';
        
        // 创建结构体/联合体类型
        const structType = new TypeInfo(typeName, kind, 0); // 初始大小为0
        structType.members = [];
        
        // 处理成员
        let currentOffset = 0;
        let maxMemberSize = 0;
        
        if (defNode.members && defNode.members.length > 0) {
            defNode.members.forEach(member => {
                const memberTypeName = this.getTypeNameFromTypeNode(member.type);
                const memberType = this.getTypeInfo(memberTypeName);
                
                if (!memberType) {
                    this.addError(`Unknown member type '${memberTypeName}'`, member.location);
                    return;
                }
                
                // 计算成员大小（所有基本类型大小为1）
                const memberSize = this.calculateTypeSize(memberType);
                
                // 对于结构体，累加偏移量；对于联合体，取最大成员大小
                if (isUnion) {
                    maxMemberSize = Math.max(maxMemberSize, memberSize);
                } else {
                    // 结构体成员：按1字节对齐
                    const memberInfo = new MemberInfo(
                        member.name,
                        memberType,
                        currentOffset,
                        member.bitField
                    );
                    structType.members.push(memberInfo);
                    currentOffset += memberSize;
                }
            });
            
            // 计算最终大小
            if (isUnion) {
                structType.size = maxMemberSize;
                // 联合体所有成员偏移量都是0
                defNode.members.forEach((member, index) => {
                    const memberTypeName = this.getTypeNameFromTypeNode(member.type);
                    const memberType = this.getTypeInfo(memberTypeName);
                    if (memberType) {
                        const memberInfo = new MemberInfo(
                            member.name,
                            memberType,
                            0, // 所有成员偏移量都是0
                            member.bitField
                        );
                        structType.members.push(memberInfo);
                    }
                });
            } else {
                structType.size = currentOffset;
            }
        } else {
            // 空结构体/联合体
            structType.size = 0;
        }
        
        // 存储到类型表
        this.typeTable.set(typeName, structType);
        this.structTable.set(typeName, structType);
        
        // 如果结构体有名称，添加到当前作用域
        if (defNode.name) {
            const structSymbol = new SymbolEntry(
                defNode.name,
                { type: structType },
                this.currentScope,
                'type'
            );
            this.currentScope.addSymbol(structSymbol);
        }
    }
	
	processTypeFromDeclaration(typeNode) {
        // 从声明中提取类型信息
        const typeName = this.getTypeNameFromTypeNode(typeNode);
        if (!this.typeTable.has(typeName)) {
            const typeInfo = this.createTypeInfoFromNode(typeNode);
            if (typeInfo) {
                this.typeTable.set(typeName, typeInfo);
            }
        }
    }
	
	createTypeInfoFromNode(typeNode) {
        const typeName = this.getTypeNameFromTypeNode(typeNode);
        const qualifiers = typeNode.getAttribute('qualifiers') || [];

        // 检查是否是结构体/联合体类型
        if (typeName === 'struct' || typeName === 'union') {
            const structName = typeNode.getAttribute('structOrUnionName');
            if (structName && this.structTable.has(structName)) {
                const structType = this.structTable.get(structName);
                const result = new TypeInfo(structName, typeName, structType.size, structType.members);
                result.qualifiers = qualifiers;
                return result;
            } else {
                // 匿名结构体/联合体
                const anonymousType = new TypeInfo(`anonymous_${typeName}`, typeName, 1);
                anonymousType.qualifiers = qualifiers;
                return anonymousType;
            }
        }
        
        // 基本类型或typedef类型
        const baseType = this.typeTable.get(typeName);
        if (baseType) {
            const result = new TypeInfo(typeName, baseType.kind, baseType.size);
            result.qualifiers = qualifiers;
            return result;
        }
        
        return null;
    }
	
	createAliasType(baseType, declarator) {
        // 创建typedef别名类型
        const aliasType = new TypeInfo(baseType.name, baseType.kind, baseType.size, [...baseType.members]);
        aliasType.qualifiers = [...baseType.qualifiers];
        
        // 处理指针
        if (declarator.pointerDepth > 0) {
            let currentType = aliasType;
            for (let i = 0; i < declarator.pointerDepth; i++) {
                const ptrType = new TypeInfo('', 'pointer', 2);
                ptrType.pointerTo = currentType;
                ptrType.qualifiers = declarator.pointerQualifiers[i] || [];
                currentType = ptrType;
            }
            return currentType;
        }
        
        // 处理数组
        if (declarator.arrayDimensions && declarator.arrayDimensions.length > 0) {
            // 计算数组类型
            let arrayType = aliasType;
            for (const dim of declarator.arrayDimensions.reverse()) {
                const arrType = new TypeInfo('', 'array', arrayType.size * (dim || 1));
                arrType.arraySize = dim;
                arrType.pointerTo = arrayType; // 使用pointerTo指向元素类型
                arrayType = arrType;
            }
            return arrayType;
        }
        
        return aliasType;
    }
	
	/**
	 * 
	 * @param {string} typeNameRaw 
	 * @returns {TypeInfo}
	 */
	getTypeInfo(typeNameRaw) {

		if (typeof typeNameRaw !== 'string') {
			return typeNameRaw;
		}
		
		let typeName = typeNameRaw;
		const ptrLocate = typeName.indexOf('*');
		const ptrSize = (ptrLocate < 0) ? 0 : typeName.length - ptrLocate;
		if (ptrLocate != -1) {
			typeName = typeName.slice(0, ptrLocate);
		}
		let result = null;

		// Get qualifiers from typeNameRaw string:
		const checkQualifiers = ['const', 'volatile'];
		let existQualifiers = [];
		const splitResult = typeName.split(' ');
		if (splitResult.length <= 0) {
			return null;
		}
		for (const qualifier of checkQualifiers) {
			if (splitResult.includes(qualifier)) {
				existQualifiers.push(qualifier);
			}
		}

		typeName = splitResult[splitResult.length - 1];
		
        // 从类型表获取类型信息
        if (this.typeTable.has(typeName)) {
            result = this.typeTable.get(typeName).duplicate();
        } else if (this.structTable.has(typeName)) {
            result = this.structTable.get(typeName).duplicate();
        } else {
			return null;	// Unable to fetch information
		}
		
		for (let i = 0; i < ptrSize; i++) {
			const ptrType = new TypeInfo('', 'pointer', 2);
			ptrType.pointerTo = result;
			result = ptrType;
		}

		result.qualifiers = existQualifiers;
        
        return result;
    }
	
	calculateTypeSize(typeInfo) {
        if (!typeInfo) return 1; // 默认大小
        
        switch (typeInfo.kind) {
            case 'basic':
            case 'device':
            case 'null':
            case 'pointer':
                return 1;
            case 'struct':
            case 'union':
                return typeInfo.size || 1;
            case 'array':
                if (typeInfo.arraySize) {
                    const elementSize = this.calculateTypeSize(typeInfo.pointerTo);
                    return elementSize * typeInfo.arraySize;
                }
				// TODO: Might be adding warning
                return 1; // 未知大小的数组
            default:
                return 1;
        }
    }

    addError(message, location = null) {
        this.errors.push({
            message,
            line: location ? location.line : 0,
            column: location ? location.column : 0
        });
    }

    addWarning(message, location = null) {
        this.warnings.push({
            message,
            line: location ? location.line : 0,
            column: location ? location.column : 0
        });
    }

    // =============== 访问者方法 ===============

    visitProgram(node) {
        // 遍历所有全局声明和函数
		node.globalDeclarations.forEach(decl => this.visit(decl));
        node.functions.forEach(func => this.visit(func));
    }

    visitFunctionDeclaration(node) {
        // 检查函数是否已声明
        const existingSymbol = this.currentScope.lookupCurrent(node.name);
        if (existingSymbol) {
            this.addError(`Function '${node.name}' is already declared`, node.location);
            return;
        }

		// 获取返回类型名称
		// Added after correctional conversation.
		const returnTypeName = this.getTypeNameFromTypeNode(node.returnType);
		if (!returnTypeName) {
			this.addError(`Invalid return type for function '${node.name}'`, node.returnType.location);
			return;
		}

        // 创建函数符号
        const funcSymbol = new SymbolEntry(
            node.name,
            {
                returnType: this.typeToString(this.getTypeNameFromTypeNode(node.returnType)),
                parameters: node.parameters.map(param => ({
                    name: param.name,
                    type: this.getTypeNameFromTypeNode(param.pointerDepth ? param : param.type) /*param.type.typeName*/
					/* Modified in 5th conversation. Whether this is correct remains to be seen! */
                }))
            },
            this.currentScope,
            'function',
            node.location
        );
		funcSymbol.owningScope = node.scope;

        this.currentScope.addSymbol(funcSymbol);
        this.currentFunction = funcSymbol;

        // 进入函数作用域
		let functionScope = node.scope;
		if (!functionScope) {
			functionScope = new Scope(this.currentScope, 'f');
			this.currentScope.children.push(functionScope);
		}
		this.currentScope = functionScope;

        // 添加参数到作用域
        node.parameters.forEach(param => {
			const gotType = this.getTypeInfo(this.getTypeNameFromTypeNode(param.pointerDepth ? param : param.type));
            const paramSymbol = new SymbolEntry(
                param.name,
                { type: gotType },
                this.currentScope,
                'parameter',
                param.location
            );
			if (gotType.isNear()) {
				paramSymbol.isNearPointer = true;
			}
            this.currentScope.addSymbol(paramSymbol);
        });

        // 分析函数体
        if (node.body) {
            this.visit(node.body);
        }

        // 返回父作用域
        this.currentScope = this.currentScope.parent;
        this.currentFunction = null;
    }

	// Modified on 1 Dec, to be verified
	// This function has manual changes!!!
	/**
	 * 
	 * @param {VariableDeclarationNode} node 
	 * @returns 
	 */
    visitVariableDeclaration(node) {
        const baseTypeName = this.getTypeNameFromTypeNode(node.type);
        const qualifiers = node.type.getAttribute('qualifiers') || [];
		
		// 检查是否有存储类说明符
		const storageClass = node.type.storageClass; // auto, register, static, extern
        
        // 获取基础类型信息
        let baseType = this.getTypeInfo(baseTypeName);
        if (!baseType) {
            this.addError(`Unknown type '${baseTypeName}'`, node.type.location);
            return;
        }
        
        // 创建带有限定符的类型
        const varType = new TypeInfo(baseType.name, baseType.kind, baseType.size, [...baseType.members]);
        varType.qualifiers = [... new Set([...baseType.qualifiers, ...qualifiers])];
		
		const warningTypes = ['device', 'content_t'];
		const warningStorages = ['volatile'];
		const warningKinds = ['pointer', 'array'];

		if ((varType.qualifiers.includes(warningStorages) || warningKinds.includes(varType.kind)) && warningTypes.includes(varType.name)) {
			this.addWarning(`Variable ${declarator.name} (with type ${varType.toString()}) cannot be stored in memory`, declarator.location);
		}

        node.declarators.forEach(declarator => {
            // 检查变量是否已声明
            const existingSymbol = this.currentScope.lookupCurrent(declarator.name);
            if (existingSymbol) {
                this.addError(`Variable '${declarator.name}' is already declared in this scope`, declarator.location);
                return;
            }

            // 创建变量类型（处理指针和数组）
            let finalType = varType;
			let pointerAccess = false;
            
            // 处理指针
            if (declarator.pointerDepth > 0) {
                let currentType = finalType;
                for (let i = 0; i < declarator.pointerDepth; i++) {
                    const ptrType = new TypeInfo('', 'pointer', 2);
                    ptrType.pointerTo = currentType;
                    ptrType.qualifiers = declarator.pointerQualifiers[i] || [];
                    currentType = ptrType;
                }
                finalType = currentType;
				if (varType.qualifiers.includes('near') && !finalType.qualifiers.includes('near')) finalType.qualifiers.push('near');
            } else {
				if (baseType.functionTo) {
					finalType.functionTo = baseType.functionTo;
				}
				// TODO: Check array support for typedef
				if (baseType.arrayDimensions && baseType.arrayDimensions.length > 0) {
					// baseType seems immutable so far
					finalType.arraySize = baseType.arraySize;
					finalType.arrayDimensions = baseType.arrayDimensions;
				}
			}
            
            // 处理数组
            if (declarator.arrayDimensions && declarator.arrayDimensions.length > 0) {
                let arrayType = finalType;
                for (const dim of declarator.arrayDimensions.reverse()) {
					if (dim.type !== 'NumericLiteral') {
						this.addWarning('Array size must be literal, or memory space is unallocated');
					}
                    const arrType = new TypeInfo('', 'array', arrayType.size * ((typeof dim.value === 'number') ? dim.value : 1));
                    arrType.arraySize = dim;
                    arrType.pointerTo = arrayType;
					arrType.qualifiers = [...finalType.qualifiers];
                    arrayType = arrType;
                }
                finalType = arrayType;
				//pointerAccess = true;
            }

            // 创建变量符号
            const varSymbol = new SymbolEntry(
                declarator.name,
                { 
                    type: finalType,
                    isConst: finalType.isConst(),
                    isVolatile: finalType.isVolatile(),
					isExtern: finalType.qualifiers.includes('extern')
                },
                this.currentScope,
                'variable',
                declarator.location
            );
			if (finalType.isNear()) {
				varSymbol.isNearPointer = true;
			}
			
			// 设置register标记
			if (storageClass === 'register') {
				varSymbol.isRegister = true;
			}
			if (storageClass === 'static') {
				varSymbol.isStatic = true;
				//varSymbol.accessThroughPointer = true;	// i.e. [omitted] need memory allocation
			}
			/*
			if (storageClass === 'extern') {
				varSymbol.accessThroughPointer = true;
			}
			*/
			if (baseTypeName === 'auto device') {
				varSymbol.isAutoDevice = true;
			}
			
			// 添加const和volatile信息
            const qualifiers = node.type.getAttribute('qualifiers') || [];
            varSymbol.isConst = qualifiers.includes('const') || finalType.isConst();
            varSymbol.isVolatile = qualifiers.includes('volatile') || finalType.isVolatile();
			varSymbol.isExtern = qualifiers.includes('extern') || finalType.isExtern();
			
			// 检查是否为全局变量
            varSymbol.isGlobal = this.currentScope === this.globalScope;
			// Meaning that the variable requires special memory space. This doesn't mean that it's a pointer itself!
			pointerAccess = pointerAccess || (varSymbol.isVolatile && !varSymbol.isRegister);
			if (finalType.kind !== 'basic') {
				varSymbol.implementAsPointer = varSymbol.implementAsPointer || pointerAccess;	// Whether still implementing them as pointer
			} else {
				// Only basic types consider 'accessThroughPointer'
				varSymbol.accessThroughPointer = pointerAccess;
			}
			declarator.dataType = varSymbol.extractType();

            this.currentScope.addSymbol(varSymbol);

            // 检查初始化表达式
            if (declarator.initializer) {
                this.visit(declarator.initializer);
                
                // 类型检查初始化表达式
                const initType = this.getExpressionType(declarator.initializer);
                if (initType && !this.isTypeCompatible(finalType, initType)) {
                    this.addError(
                        `Cannot initialize '${this.typeToString(finalType)}' with '${this.typeToString(initType)}'`,
                        declarator.initializer.location
                    );
				}

                varSymbol.initialized = true;
            }
			// 检查const变量初始化
			if (finalType.isConst() && !varSymbol.isAutoDevice && !declarator.initializer) {
				this.addError(`Const variable '${declarator.name}' must be initialized or be an automatically-linked device`, declarator.location);
			}
        });
    }

	/**
	 * 
	 * @param {NumericLiteralNode} node 
	 */
	visitNumericLiteral(node) {
		//node.dataType = this.typeTable.get('int');
		if (node.value === true || node.value === false) {
			node.dataType = this.typeTable.get('bool');
		} else if (node.raw.indexOf('.') !== -1 || node.raw.slice(-1) === 'f') {
			node.dataType = this.typeTable.get('float');
		} else {
			node.dataType = this.typeTable.get('int');
		}
	}

	/**
	 * 
	 * @param {StringLiteralNode} node 
	 * @remark Specially, string literal is considered 'char', unless specially converted!
	 */
	visitStringLiteral(node) {
		node.dataType = this.typeTable.get('char');
	}

	/**
	 * 
	 * @param {NullLiteralNode} node 
	 */
	visitNullLiteral(node) {
		node.dataType = this.typeTable.get('null_t');
	}

	// 5th conversation
	// 新增辅助方法：从类型节点中提取类型名称
	// 7th (1 Dec)
	// 修改getTypeNameFromTypeNode以处理指针和结构体
	// Priority adjusted manually !!!
	// Also add pointer dereference manually
	// This function doesn't case const qualifier
    getTypeNameFromTypeNode(typeNode) {
        if (!typeNode) return null;
        
		let prefix = "";
		const ptrSuffix = "*".repeat(typeNode.pointerDepth);
		
		if (typeNode.type === 'TypeSpecifier' && typeNode.getAttribute('qualifiers')) {
			const attributes = typeNode.getAttribute('qualifiers');
			if (attributes.length > 0)
				prefix = attributes.join(' ') + ' ';
		}

		// 处理结构体/联合体类型
        if (typeNode.type === 'TypeSpecifier' && 
            (typeNode.typeName === 'struct' || typeNode.typeName === 'union')) {
            const structName = typeNode.getAttribute('structOrUnionName');
            return prefix + (structName || typeNode.typeName) + ptrSuffix;
        }
		
        // 如果是TypeSpecifier节点
        if (typeNode.typeName && typeof typeNode.typeName === 'string') {
            return prefix + typeNode.typeName + ptrSuffix;
        }
		if (typeof typeNode.type === 'object') {
			return prefix + this.getTypeNameFromTypeNode(typeNode.type) + ptrSuffix;
		}
        
        // 如果是标识符节点（处理typedef定义的类型）
        if (typeNode.type === 'Identifier') {
            return typeNode.name + ptrSuffix;
        }
        
        return null;
    }

    visitIdentifier(node) {

		if (node.name.length && node.name[0] === '@') {
			if (node.name === '@counter') {
				this.addWarning(`Deprecated to use @counter inside program`, node.getAttribute('location'));
			}
			if (objectList.includes(node.name)) {
				node.dataType = this.typeTable.get('item_t');
			} else if (liquidList.includes(node.name)) {
				node.dataType = this.typeTable.get('liquid_t');
			} else if (unitList.includes(node.name)) {
				node.dataType = this.typeTable.get('unit_t');
			} else {
				node.dataType = this.typeTable.get('content_t');
			}
			
			return;
		}
        const symbol = this.currentScope.lookup(node.name);
        if (!symbol) {
            this.addError(`Undeclared identifier '${node.name}'`, node.location);
            return;
        }

        symbol.used = true;
        node.symbol = symbol; // 将符号关联到节点

        // 设置节点类型
        if (symbol.kind === 'variable' || symbol.kind === 'parameter') {
            node.dataType = this.getTypeInfo(symbol.type.type);
        }
    }

	/**
	 * 
	 * @param {CastExpression} node 
	 */
	visitCastExpression(node) {
		this.visit(node.expression);
		node.dataType = this.getExpressionType(node);
	}

    visitBinaryExpression(node) {
        this.visit(node.left);
        this.visit(node.right);

        const leftType = this.getExpressionType(node.left);
        const rightType = this.getExpressionType(node.right);

        if (!leftType || !rightType) {
            return;
        }

        // 检查操作符的类型兼容性
        if (!this.isTypeCompatibleForOperator(node.operator, leftType, rightType)) {
            this.addError(
                `Operator '${node.operator}' cannot be applied to types '${leftType}' and '${rightType}'`,
                node.location
            );
            return;
        }

        // 设置表达式结果类型
        node.dataType = this.getResultType(node.operator, leftType, rightType);
    }

    visitUnaryExpression(node) {
        this.visit(node.argument);
		const argType = this.getExpressionType(node.argument);
		
		if (!argType) return;
		
		const operator = node.operator;
		
		switch (operator) {
			case '*': // 解引用操作
				if (!this.isValidDereference(argType)) {
					this.addError(`Cannot dereference non-pointer type '${this.typeToString(argType)}'`, node.location);
					return;
				}
				
				// 设置表达式结果类型
				node.dataType = argType.pointerTo;
				break;
				
			case '&': // 取地址操作
				// 检查操作数是否为左值
				if (!this.isLValue(node.argument)) {
					this.addError(`Cannot take address of non-lvalue`, node.location);
					return;
				}
				
				// 检查是否为register变量
				if (this.isRegisterVariable(node.argument)) {
					this.addError(`Cannot take address of register variable`, node.location);
					return;
				}
				
				// 标记变量已被取地址
				this.markVariableAsAddressed(node.argument);
				
				// 创建指针类型
				const ptrType = new TypeInfo('', 'pointer', 2);
				ptrType.pointerTo = argType;
				node.dataType = ptrType;
				break;
				
			case '+': case '-': // 正负号
				if (!this.isNumericType(argType.name)) {
					this.addError(`Unary '${operator}' requires numeric type`, node.location);
					return;
				}
				node.dataType = argType;
				break;
				
			case '~': // 按位取反
				if (!this.isIntegerType(argType.name)) {
					this.addError(`Unary '${operator}' requires integer type`, node.location);
					return;
				}
				node.dataType = argType;
				break;
				
			case '!': // 逻辑非
				node.dataType = this.typeTable.get('int'); // 返回int类型（0或1）
				break;
				
			case '++': case '--': // 递增递减
				if (!this.isLValue(node.argument)) {
					this.addError(`'${operator}' requires lvalue`, node.location);
					return;
				}
				
				if (!this.isNumericType(argType.name) && !argType.isPointerImpl()) {
					this.addError(`'${operator}' requires numeric type`, node.location);
					return;
				}
				
				// 检查const变量
				if (argType.isConst()) {
					this.addError(`Cannot modify const variable with '${operator}'`, node.location);
				}
				
				node.dataType = argType;
				break;
				
			default:
				this.addError(`Unknown unary operator '${operator}'`, node.location);
				break;
		}
    }
	
	// 添加辅助方法检查是否有效的解引用操作
	isValidDereference(type) {
		return type && (type.kind === 'pointer' || type.kind === 'array');
	}
	
	// 添加辅助方法检查是否为register变量
	isRegisterVariable(node) {
		if (node.type === 'Identifier') {
			const symbol = this.currentScope.lookup(node.name);
			return symbol && symbol.isRegister;
		}
		return false;
	}
	
	// 添加辅助方法标记变量已被取地址
	markVariableAsAddressed(node) {
		if (node.type === 'Identifier') {
			const symbol = this.currentScope.lookup(node.name);
			if (symbol) {
				symbol.isAddressed = true;
				if (symbol.kind === 'variable') {
					symbol.accessThroughPointer = true;
				} else if (symbol.kind === 'struct' || symbol.kind === 'union') {
					symbol.implementAsPointer = true;
				}
			}
			
			// 被取地址的变量不能放在寄存器中
			if (symbol.isRegister) {
				this.addWarning(`Register variable '${node.name}' has its address taken, will be stored in memory`, node.location);
				symbol.isRegister = false; // 强制取消register优化
			}
		} else if (node.type === 'MemberExpression') {
			// 处理结构体成员被取地址的情况
			const object = node.getChild(0);
			this.markVariableAsAddressed(object);
		} else if (node.type === 'UnaryExpression' && node.operator === '*') {
			// 解引用表达式的地址（如&*ptr）等于ptr
			const arg = node.argument;
			/*
			if (arg.type === 'Identifier') {
				const symbol = this.currentScope.lookup(arg.name);
				if (symbol && symbol.kind === 'variable') {
					symbol.isAddressed = true;
					//symbol.accessThroughPointer = true;
				}
			}
				*/
			this.markVariableAsAddressed(arg);
		}
	}

    visitAssignmentExpression(node) {
        this.visit(node.left);
        this.visit(node.right);

        const leftType = this.getExpressionType(node.left);
        let rightType = this.getExpressionType(node.right);

        if (!leftType || !rightType) {
            return;
        }

		let compatible = false;
		let resultType = leftType;
		if (node.operator === '=') {
			compatible = this.isTypeCompatible(leftType, rightType);
		} else {
			const operation = node.operator.slice(null, -1);
			compatible = this.isTypeCompatibleForOperator(operation, leftType, rightType);
			if (compatible) {
				const probableResult = this.getResultType(operation, leftType, rightType);
				compatible = compatible && this.isTypeCompatible(leftType, probableResult);
				resultType = probableResult;
			}
		}

        // 检查赋值兼容性
        if (!compatible) {
			let funcFlag = false;
			if (node.right.type === 'Identifier' && node.right.symbol && node.right.symbol.kind === 'function') {
				// Try function pointer
				const funcType = new TypeInfo('', 'function', 1);
				funcType.functionTo = new SymbolEntry(
					'',
					{
						returnType: node.right.symbol.type.returnType,
						parameters: node.right.symbol.type.parameters
					},
					this.globalScope,
					'function',
					node.right.location
				);
				// Identifier itself can be assigned this:
				node.dataType = funcType;
				rightType = funcType;
				funcFlag = this.isTypeCompatible(leftType, rightType);
				const rightTypeReadable = this.typeToString(rightType);
				if (!funcFlag) {
					this.addError(`Incorrect type '${rightTypeReadable}' in assignment of function pointer '${leftType}'`,
					node.location);
				}
			} else {
				this.addError(
                `Cannot assign '${rightType}' to '${leftType}'`,
                node.location
				);
			}
			if (!funcFlag) {
				
				return;
			}
        }
		
		// TODO: Some issues about "const int*" / "int* const" might exist
		
		// 检查左值是否为const
        if (leftType.isConst()) {
            this.addError(`Cannot assign to const variable`, node.location);
        }

        // 检查左值
        if (!this.isLValue(node.left)) {
            this.addError(`Assignment requires lvalue`, node.location);
        }

        node.dataType = resultType;
    }
	
	// 添加成员访问支持
    visitMemberExpression(node) {
        const object = node.getChild(0);
        const member = node.getChild(1);
        const computed = node.getAttribute('computed');
		const operator = node.getAttribute('operator'); // '.' 或 '->'
        
        this.visit(object);
        const objectType = this.getExpressionType(object);
        
        if (!objectType) return;
        
        // 数组下标访问 (Updated 8 Feb: also for strings now!)
        if (computed) {
            if (objectType.kind !== 'array' && objectType.kind !== 'pointer') {
				if (objectType.kind === 'basic' && objectType.name === 'char') {
					if (this.targetVersion < 150) {
						this.addError('String index access requires at least v150', node.location);
						return;
					} else {
						node.setAttribute('stringAccess', true);
						/**
						 * @type {TypeInfo}
						 */
						const dataType = objectType.duplicate();
						dataType.qualifiers = [...new Set([...dataType.qualifiers, 'const'])];
						node.dataType = dataType;
					}
					
				} else {
					this.addError(`Cannot use subscript on ${this.targetVersion >= 150 ? 'non-array nor string' : 'non-array'} type`, node.location);
                	return;
				}
                
            }
            
            this.visit(member);
            const indexType = this.getExpressionType(member);
            if (indexType && indexType.name !== 'int') {
                this.addWarning(`Array index should be of type 'int'`, member.location);
            }
            
            if (objectType.kind === 'array') {
                node.dataType = objectType.pointerTo;
            } else if (objectType.kind === 'pointer') {
                node.dataType = objectType.pointerTo;
            }
            return;
        }
        
		// 结构体/联合体成员访问
		let targetType = objectType;
		
		// 处理指针操作符 '->'
		if (operator === '->') {
			if (objectType.kind !== 'pointer') {
				this.addError(`'->' operator requires pointer to struct/union`, node.location);
				return;
			}
			
			if (!objectType.pointerTo) {
				this.addError(`Cannot dereference incomplete pointer type`, node.location);
				return;
			}
			
			// 解引用指针，获取指向的类型
			targetType = objectType.pointerTo;
		}
		// 处理点操作符 '.'
		else if (operator === '.') {
			// 点操作符要求对象是结构体/联合体类型，不能是指针
			if (objectType.kind === 'pointer') {
				this.addError(`Cannot use '.' operator on pointer type, use '->' instead`, node.location);
				return;
			}
		}
		
		// 检查目标类型是否为结构体或联合体
		if (targetType.kind !== 'struct' && targetType.kind !== 'union') {
			this.addError(`Member access requires struct/union type, got '${this.typeToString(targetType)}'`, node.location);
			return;
		}
		
		
		if (member.type !== 'Identifier') {
			this.addError(`Member name must be an identifier`, member.location);
			return;
		}
		
		const memberName = member.name;
		const memberInfo = targetType.members.find(m => m.name === memberName);
		
		if (!memberInfo) {
			this.addError(`'${targetType.name}' has no member named '${memberName}'`, member.location);
			return;
		}
		
		// 记录成员信息
		node.dataType = memberInfo.type;
		node.memberInfo = memberInfo;
		
		// 设置节点属性，便于代码生成阶段使用
		node.setAttribute('memberOffset', memberInfo.offset);
		node.setAttribute('memberName', memberName);
		
		// 如果是通过指针访问，记录解引用信息
		if (operator === '->') {
			node.setAttribute('dereferenced', true);
		}
		
    }

    visitFunctionCall(node) {
        this.visit(node.callee);

        // 检查参数
        node.arguments.forEach(arg => this.visit(arg));

        // 检查函数是否存在
        if (node.callee.type !== ASTNodeType.IDENTIFIER) {
            this.addError(`Function call target must be an identifier`, node.callee.location);
            return;
        }

        const funcSymbol = this.currentScope.lookup(node.callee.name);
        if (!funcSymbol || (funcSymbol.kind !== 'function' && 
			(!funcSymbol.type.type || funcSymbol.type.type.kind !== 'function'))) {
            this.addError(`Undeclared function '${node.callee.name}'`, node.callee.location);
            return;
        }
		let expectedParams = funcSymbol.type.parameters || [], isFunctionPointer = false;
		if (funcSymbol.kind !== 'function' && funcSymbol.type.type.kind === 'function') {
			expectedParams = funcSymbol.type.type.functionTo.type.parameters;
			isFunctionPointer = true;
		}

        // 检查参数数量
       
        if (node.arguments.length !== expectedParams.length) {
            this.addError(
                `Function '${node.callee.name}' expects ${expectedParams.length} arguments, but ${node.arguments.length} were provided`,
                node.location
            );
            return;
        }

        // 检查参数类型
        node.arguments.forEach((arg, index) => {
            const argType = this.getExpressionType(arg);
            const expectedType = expectedParams[index].type;
            
            if (argType && expectedType && !this.isTypeCompatible(expectedType, argType)) {
                this.addError(
                    `Argument ${index + 1} of '${node.callee.name}' expects '${expectedType}', but got '${argType}'`,
                    arg.location
                );
            }
        });

		if (isFunctionPointer) {
			node.dataType = this.getTypeInfo(funcSymbol.type.type.functionTo.type.returnType);
		} else {
			node.dataType = this.getTypeInfo(funcSymbol.type.returnType);
		}
		node.setAttribute('isFunctionPointer', isFunctionPointer);
    }

    visitBuiltinCall(node) {
		const funcSymbol = this.currentScope.lookup(node.functionName);
		if (!funcSymbol || funcSymbol.kind !== 'function') {
			this.addError(`Unknown builtin function '${node.functionName}'`, node.location);
			return;
		}

		// 检查参数
		node.arguments.forEach(arg => this.visit(arg));

		// 特殊的内建函数参数检查
		switch (node.functionName) {
			case 'printchar':
			case 'format':
				if (this.targetVersion < 154) {
					this.addError(`${node.functionName} requires v154 or higher`, node.location);
				}
				break;
			case 'set':
				if (node.arguments.length < 2) {
					this.addError(`'set' requires at least 2 arguments`, node.location);
				}
				break;
				
			case 'op':
				if (node.arguments.length < 3) {
					this.addError(`'op' requires at least 3 arguments`, node.location);
				}
				break;
				
			case 'read':
			case 'write':
				if (node.arguments.length !== 3) {
					this.addError(`'${node.functionName}' requires exactly 3 arguments`, node.location);
				}
				break;
				
			default:
				// I don't actually know what this is for...
				if (!funcSymbol.type.hasVarArgs) {
					const expectedParams = funcSymbol.type.parameters || [];
					if (node.arguments.length !== expectedParams.length) {
						this.addError(
							`Function '${node.functionName}' expects ${expectedParams.length} arguments, but ${node.arguments.length} were provided`,
							node.location
						);
					}
				}
				break;
		}

		node.dataType = this.getTypeInfo(funcSymbol.type.returnType);
	}

	// !! Has manual changes !!
    visitIfStatement(node) {
        this.visit(node.test);
        
        // 检查条件表达式类型
        const testType = this.getExpressionType(node.test);
        if (testType && testType.name !== 'bool') {
            this.addWarning(`Condition expression should be of type 'bool'`, node.test.location);
        }

        this.visit(node.consequent);
        if (node.alternate) {
            this.visit(node.alternate);
        }
    }

	/**
	 * 
	 * @param {ConditionalExpressionNode} node 
	 * @remark Manually written. How could AI forget this?
	 */
	visitConditionalExpression(node) {
		this.visit(node.test);
		const testType = this.getExpressionType(node.test);
		if (testType && testType.name !== 'bool') {
            this.addWarning(`Condition expression should be of type 'bool'`, node.test.location);
        }
		this.visit(node.consequent);
		this.visit(node.alternate);
		const consequentType = this.getExpressionType(node.consequent);
		const alternateType = this.getExpressionType(node.alternate);
		if (!this.isTypeCompatible(consequentType, alternateType)) {
			this.addError(`Conditional expression must return the same type`, node.consequent.location);
		}
		node.dataType = consequentType;
	}

    visitWhileStatement(node) {
        this.visit(node.test);
        
        // 检查条件表达式类型
        const testType = this.getExpressionType(node.test);
        if (testType && testType.name !== 'bool') {
            this.addWarning(`Loop condition should be of type 'bool'`, node.test.location);
        }

        this.visit(node.body);
    }

	// FOR LOOP DOESN'T HAVE ITS SCOPE
    visitForStatement(node) {
        // 进入新的作用域
        //const forScope = new Scope(this.currentScope, 'block');
        //this.currentScope.children.push(forScope);
        //this.currentScope = forScope;

        if (node.init) this.visit(node.init);
        if (node.test) {
            this.visit(node.test);
            const testType = this.getExpressionType(node.test);
            if (testType && testType.name !== 'bool') {
                this.addWarning(`Loop condition should be of type 'bool'`, node.test.location);
            }
        }
        if (node.update) this.visit(node.update);
        if (node.body) this.visit(node.body);

        // 退出作用域
        //this.currentScope = this.currentScope.parent;
    }

    visitReturnStatement(node) {
        if (node.argument) {
            this.visit(node.argument);
            
            if (this.currentFunction) {
                const returnType = this.currentFunction.type.returnType;
                const argType = this.getExpressionType(node.argument);
                
                if (returnType !== 'void' && argType && !this.isTypeCompatible(returnType, argType)) {
                    this.addError(
                        `Return type mismatch: expected '${returnType}', but got '${argType}'`,
                        node.argument.location
                    );
                }

				node.dataType = this.getTypeInfo(returnType);
            }
        } else if (this.currentFunction && this.currentFunction.type.returnType !== 'void') {
            this.addError(`Function must return a value`, node.location);
        } else {
			node.dataType = this.getTypeInfo('void');
		}
    }

    visitCompoundStatement(node) {
        // 进入新的块作用域
        let blockScope = node.scope;
		if (!blockScope) {
			blockScope = new Scope(this.currentScope, 'b');
			this.currentScope.children.push(blockScope);
		}
        this.currentScope = blockScope;

        // 遍历块内的所有语句
        node.statements.forEach(stmt => this.visit(stmt));

        // 退出作用域
        this.currentScope = this.currentScope.parent;
    }

	visitInitializerList(node) {
		const declaratorTypes = ['VariableDeclarator', 'Declarator'];
		node.dataType = this.typeTable.get('null_t').duplicate();	// size might be modified
		node.dataType.size = 0;
		node.children.forEach(child => {
			this.visit(child);
			node.dataType.size += child.dataType ? child.dataType.size : 0;
		});
		// Assign a virtual symbol for it
		if (!node.parent || (node.parent.type !== 'InitializerList'
			 && (!declaratorTypes.includes(node.parent.type) || !node.parent.symbol))) {
			const virtualSymbol = new SymbolEntry(
				`__initializer_${this.virtualCounter++}`, node.dataType, this.currentScope, 'array', null, node.dataType.size);
			virtualSymbol.isConst = true;
			virtualSymbol.isVolatile = true;
			//virtualSymbol.accessThroughPointer = true;
			virtualSymbol.implementAsPointer = true;
			virtualSymbol.needMemoryAllocation = true;
			virtualSymbol.isVirtualSymbol = true;
			virtualSymbol.isStatic = true;
			node.symbol = virtualSymbol;
			this.currentScope.addSymbol(virtualSymbol);
		}
	}

    // =============== 类型检查辅助方法 ===============
	/**
	 * @param {ASTNode} node 
	 * @returns {TypeInfo | null}
	 */
	getExpressionType(node) {
        if (!node) return null;

        // 如果节点已经有数据类型，直接返回
        if (node.dataType) {
            return node.dataType;
			//return this.typeTable.get(node.dataType) ?? node.dataType;
        }

        // 根据节点类型推断类型
        switch (node.type) {
			case 'ConditionalExpression':
				return this.getExpressionType(node.consequent);

            case 'Identifier':
                const symbol = this.currentScope.lookup(node.name);
				if (!symbol) {
					return null;
				}
				if (symbol.kind === 'function') {
					let funcType = new TypeInfo(node.name, 'function');
					funcType.functionTo = symbol;
					return funcType;
				}
                return symbol.myType();

            case 'MemberExpression':
                return node.dataType;

            case 'UnaryExpression':
                if (node.operator === '*') {
                    // 解引用操作
                    const argType = this.getExpressionType(node.argument);
                    if (argType && argType.kind === 'pointer') {
                        return argType.pointerTo;
                    }
                    return null;
                } else if (node.operator === '&') {
                    // 取地址操作
                    const argType = this.getExpressionType(node.argument);
                    if (argType) {
                        const ptrType = new TypeInfo('', 'pointer', 2);
                        ptrType.pointerTo = argType;
                        return ptrType;
                    }
                    return null;
                }
                // 其他一元操作符
				/*
				// 其他一元操作符
				const argType = this.getExpressionType(node.argument);
				if (argType) {
					// 对于递增递减操作，返回与参数相同的类型
					if (node.operator === '++' || node.operator === '--') {
						return argType;
					}
					// 对于其他一元操作符，返回数值类型
					return this.typeTable.get('int');
				}
				return null;
				*/
                return this.getExpressionType(node.argument);

            case 'BinaryExpression':
                // 对于指针算术等操作，需要特殊处理
                const leftType = this.getExpressionType(node.left);
                const rightType = this.getExpressionType(node.right);
                
                if (node.operator === '+' || node.operator === '-') {
                    // 指针算术
                    if (leftType && leftType.kind === 'pointer') {
                        return leftType;
                    }
                    if (rightType && rightType.kind === 'pointer') {
                        return rightType;
                    }
                }
                
                // 默认返回左操作数类型
                return leftType;
				
			case 'AssignmentExpression':
				// 赋值表达式的类型是左操作数的类型
				return this.getExpressionType(node.left);
			
			case 'CastExpression':
				// 类型转换表达式的类型是转换后的类型
				if (node.typeNode) {
					const typeNode = node.typeNode;
					const typeName = this.getTypeNameFromTypeNode(typeNode);
					let baseType = this.getTypeInfo(typeName);
					
					return baseType;
				}
				return null;

            case 'NumericLiteral':
                return this.typeTable.get('int');

            case 'StringLiteral':
                const charPtrType = new TypeInfo('', 'pointer', 2);
                charPtrType.pointerTo = this.typeTable.get('char');
                return charPtrType;

            case 'CharacterLiteral':
                return this.typeTable.get('char');

			case 'InitializerList':
            case 'NullLiteral':
                return this.typeTable.get('null_t');

            default:
                return null;
        }
    }

	// Currently unused
	isValidMemberAccessOperator(operator) {
		return operator === '.' || operator === '->';
	}

	/**
	 * 
	 * @param {TypeInfo} targetTypeRaw
	 * @param {TypeInfo} sourceTypeRaw
	 */
	isSameType(targetTypeRaw, sourceTypeRaw) {
		const targetType = targetTypeRaw.duplicate(), sourceType = sourceTypeRaw.duplicate();
		const ignoredQualifiers = ['auto', 'volatile', 'static', 'extern', 'near'];
		sourceType.qualifiers = sourceType.qualifiers.filter(
			item => (!ignoredQualifiers.includes(item)));	// 'const' of source does not matter
		targetType.qualifiers = targetType.qualifiers.filter(
			item => (!ignoredQualifiers.includes(item) && item !== 'const'));
		return this.typeToString(sourceType) == this.typeToString(targetType);
	}

    // 修改类型兼容性检查以支持指针和结构体
    isTypeCompatible(targetTypeRaw, sourceTypeRaw) {
		
		/**
		 * @type {TypeInfo}
		 */
		let targetType = targetTypeRaw;
		/**
		 * @type {TypeInfo}
		 */
		let sourceType = sourceTypeRaw;
		// TODO: Might be sth like '*'
		if (typeof targetType === 'string') {
			targetType = this.getTypeInfo(targetType);
		}
		if (typeof sourceType === 'string') {
			sourceType = this.getTypeInfo(sourceType);
		}

		targetType = targetType.duplicate();
		sourceType = sourceType.duplicate();
		
		if (!targetType || !sourceType) return false;
        
		// Remove auto and volatile qualifier for both sides:
		const ignoredQualifiers = ['auto', 'volatile', 'static', 'extern', 'near'];
		sourceType.qualifiers = sourceType.qualifiers.filter(
			item => (!ignoredQualifiers.includes(item) && (sourceType.isStrictPointerImpl() || item !== 'const')) );	// 'const' of source does not matter
		targetType.qualifiers = targetType.qualifiers.filter(
			item => (!ignoredQualifiers.includes(item) && item !== 'const'));

		const specialContents = ['item_t', 'liquid_t', 'unit_t', 'block_t', 'content_t'];
		
        // 相同类型总是兼容
        if (this.typeToString(targetType) === this.typeToString(sourceType)) {
            return true;
        }
		if (specialContents.includes(targetType.name) && specialContents.includes(sourceType.name)) {
			return true;
		}
		// Clear names for checker
		if (targetType.kind === 'function' && sourceType.kind === 'function') {
			const duplicateTarget = targetType.duplicate(), duplicateSource = sourceType.duplicate();
			duplicateTarget.name = "";
			duplicateSource.name = "";
			return this.typeToString(duplicateTarget) === this.typeToString(duplicateSource);
		}
        
        // void指针可以接受任何指针类型
        if (targetType.kind === 'pointer' && sourceType.kind === 'pointer') {
            if (targetType.pointerTo && targetType.pointerTo.name === 'void') {
                return true;
            }
            if (sourceType.pointerTo && sourceType.pointerTo.name === 'void') {
                return true;
            }
            // 指针类型兼容性检查
            return this.isTypeCompatible(targetType.pointerTo, sourceType.pointerTo);
        }
        
        // 数组到指针的转换
        if (targetType.kind === 'pointer' && sourceType.kind === 'array') {
            return this.isTypeCompatible(targetType.pointerTo, sourceType.pointerTo);
        }
        
        // 数值类型之间的兼容性
        const numericTypes = ['int', 'char', 'short', 'long', 'float', 'double', 'signed', 'unsigned', 'bool'];
        if (numericTypes.includes(targetType.name) && numericTypes.includes(sourceType.name)) {
            return true;
        }

		// TODO: Let's regard this as a feature...
		// null_t can be assigned to everything
        if (sourceType.name === 'null_t') {
            return true;
        }
        
        // 结构体/联合体类型兼容性
        if (targetType.kind === 'struct' || targetType.kind === 'union') {
            if (sourceType.kind === targetType.kind && targetType.name === sourceType.name) {
                return true;
            }
        }
        
        return false;
    }

	// ! Has manual content !
    isTypeCompatibleForOperator(operator, leftTypeRaw, rightTypeRaw) {
		
		let leftType = leftTypeRaw, rightType = rightTypeRaw;
		// TODO: Might be sth like '*'
		if (typeof leftType === 'string') {
			leftType = this.getTypeInfo(leftType);
		}
		if (typeof rightType === 'string') {
			rightType = this.getTypeInfo(rightType);
		}
		
		if (!leftType || !rightType) return false;
		
        const arithmeticOps = ['+', '-', '*', '/', '%'];
		const pointerOps = ['+', '-'];
        const comparisonOps = ['==', '!=', '<', '<=', '>', '>='];
        const logicalOps = ['&&', '||'];
        const bitwiseOps = ['&', '|', '^', '<<', '>>'];
		const pointerCompatible = ['pointer', 'array'];

		// No operator is allowed for struct / union
		// (Manually written)
		if (leftType.kind === 'struct' || leftType.kind === 'union' || leftType.kind === 'function')
			return false;

		if (rightType.kind === 'struct' || rightType.kind === 'union' || rightType.kind === 'function')
			return false;
		// (End)
		
		// (Manually written) (They should BE NAMES)
		// (As well as pointer execution)

        // 算术运算符要求数值类型
        if (arithmeticOps.includes(operator)) {
			const leftIsPointer = pointerCompatible.includes(leftType.kind);
			const rightIsPointer = pointerCompatible.includes(rightType.kind);
			if (leftIsPointer && rightIsPointer) {
				return false;
			}
			if ((leftIsPointer || rightIsPointer) && (!pointerOps.includes(operator))) {
				return false;
			}
            return (this.isNumericType(leftType.name) || leftIsPointer) && (this.isNumericType(rightType.name) || rightIsPointer);
        }

        // 比较运算符要求兼容类型
        if (comparisonOps.includes(operator)) {
			if (pointerCompatible.includes(leftType.kind) && pointerCompatible.includes(rightType.kind)) {
				return this.isTypeCompatible(leftType.pointerTo, rightType.pointerTo);
			}
            return this.isTypeCompatible(leftType, rightType);
        }

        // 逻辑运算符要求布尔上下文（这里简化为int类型）
        if (logicalOps.includes(operator)) {
            return this.isLogicalType(leftType.name) && this.isLogicalType(rightType.name);
        }

        // 位运算符要求整型
        if (bitwiseOps.includes(operator)) {
            return this.isIntegerType(leftType.name) && this.isIntegerType(rightType.name);
        }

        return true; // 其他操作符暂时宽松处理
    }
	
	// 添加类型转字符串方法
    typeToString(typeInfo) {
        if (!typeInfo) return 'unknown';
		if (typeof typeInfo === 'string') {
			return typeInfo;
		}
        
        return typeInfo.toString();
    }

	// Check for LVal beforehand
    isTypeCompatibleForUnaryOperator(operator, argTypeRaw) {
		
		let argType = argTypeRaw;
		if (typeof argType === 'string') {
			argType = this.getTypeInfo(argType);
		}
		
        const arithmeticOps = ['+', '-'];
        const logicalOps = ['!'];
        const bitwiseOps = ['~'];
        const incrementOps = ['++', '--'];

        // 算术一元运算符要求数值类型
        if (arithmeticOps.includes(operator)) {
            return this.isNumericType(argType);
        }

        // 逻辑非要求布尔上下文
        if (logicalOps.includes(operator)) {
            return argType === 'bool';
        }

        // 位非要求整型
        if (bitwiseOps.includes(operator)) {
            return this.isIntegerType(argType);
        }

        // 递增递减要求左值且为数值类型
        if (incrementOps.includes(operator)) {
            return this.isNumericType(argType);
        }
		
		if (operator === '*') {
			return argType.kind === 'pointer';
		}

        return true;
    }

    getResultType(operator, leftType, rightType) {
		const comparisonOps = ['==', '!=', '<', '<=', '>', '>=', '||', '&&'];
		const pointerOps = ['+', '-'];
        // 在实际编译器中需要更精确的类型推导
		if (comparisonOps.includes(operator)) return this.typeTable.get('bool');
		if (pointerOps.includes(operator)) {
			if (leftType.kind === 'pointer') return leftType;
			if (rightType.kind === 'pointer') return rightType;
		}
        return leftType;
    }

    getUnaryResultType(operator, argType) {
        // 一元表达式通常保持操作数类型
		
		if (operator === '&') {
			// Return a pointer
			const ptrType = new TypeInfo('', 'pointer', 2);
			ptrType.pointerTo = argType;
			return ptrType;
		}
		
		if (operator === '*') {
			// Return a pointer's pointing-to
			return argType.pointerTo;
		}

		if (operator === '!') {
			return this.typeTable.get('bool');
		}
		
        return argType;
    }

    // 修改isLValue以支持成员访问
    isLValue(node) {
        // 标识符是左值
        if (node.type === 'Identifier') {
            return true;
        }

        // 成员访问是左值
        if (node.type === 'MemberExpression') {
            return true;
        }

        // 解引用是左值
        if (node.type === 'UnaryExpression' && node.operator === '*') {
            return true;
        }

        // 数组下标是左值
        if (node.type === 'MemberExpression' && node.getAttribute('computed')) {
            return true;
        }

        // 其他情况暂时认为不是左值
        return false;
    }

    isNumericType(type) {
        const numericTypes = ['int', 'char', 'short', 'long', 'float', 'double', 'signed', 'unsigned'];
        return numericTypes.includes(type);
    }

    isIntegerType(type) {
        const integerTypes = ['int', 'char', 'short', 'long', 'signed', 'unsigned'];
        return integerTypes.includes(type);
    }

	isLogicalType(type) {
		const logicalTypes = ['bool'];
		return this.isNumericType(type) || logicalTypes.includes(type);
	}

    // 默认访问方法
    visitDefault(node) {
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
    }
}