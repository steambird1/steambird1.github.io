# C++ 快速入门

## 5.1 指针与类型转换

### 指针

之前我们提到过变量的地址。
接下来，让我们认识一种神奇的东西——指针。
不过，在认识它之前，我们需要了解：变量是怎么存储的？

#### 内存空间

在电脑里面，有一片连续的空间——内存空间。它被划分成小块，一块的大小就是一**字节**。自然，为了方便管理，每一小块有自己的地址。这样，只要知道地址，便可以访问并修改内存。每个变量也都是这样存储的，因此，修改了内存也相当于修改了变量的值。
**注意：一个变量不一定只占据1个小块。大部分变量会占据连续的多个块（取决与其大小），如`int`占用4字节（32位）或8字节（64位）等。**

#### 再回到指针

现在，我们再回到指针。指针也是一种变量，不过它存储的值是另一块空间的地址。
那么指针怎么使用呢？既然它的值是地址，我们必须想办法知道变量的地址。
同时，既然它不是普通的变量，我们需要标记它一下，给它一个 `*` 标记。
通过 `&` 运算符，便可以知道变量的地址。举例如下：
```c++
int a = 0;
int *p = &a;
```
不过要注意一点：
```c++
int a = 0, b = 1;
int *p = &a, q = &b;	// 错误
```
这样是不行的，`*` 只修饰单个变量。因此，需要把最后一行改成：
```c++
int *p = &a, *q = &b;
```

#### 应用我们的指针

有了指针，我们还要尝试通过指针设置或取得它的值。
通过 `*` 运算符，便可以得到“可以赋值的值”。像这样：
```c++
#include <iostream>
using namespace std;

int main() {
	int a = 5;
	int *p = &a;
	cout << (*p) << " ";
	(*p) = 10;
	cout << (*p) << endl;
	return 0;
}
```
如果运行正常，输出应该是 `5 10`。这样，我们的指针就有了实际用途。

#### 动态数组

数组也是指针，因此，`[]` 运算符也可以用于指针。
其实，`a[b]` 相当于 `*(a+b)`。因此，`a[1]` 写成 `1[a]` 也是可以的。（当然，这种写法除了装13以外没有任何用处）

有时，我们可能会遇到这样的情况：
给定列表 A,B，它们的大小相加是 10,000,000。
如果用数组，那么就会遇到问题：
```c++
int a[10000000],b[10000000];
```
这样，有一半的空间就被白白浪费了。
这时，指针就派上了用场——它可以接受**动态分配**的内存，像这样：
```c++
int *a = new int[n];	// n 只要是整型变量
```
`new` 的语法很简单，就是 `new 类型[大小]` (`[大小]` 可以省略——省略了就只有一个的大小，也可以是变量，当然常量也可以）。

对于动态分配的内存，**如果不是信奥方面（判题机一般禁止这么做）**，需要用 `delete` 释放。（如果 `new` 时附带了大小，则需要用 `delete[]`），像这样：
```c++
delete[] a;
```

### 类型转换

前面提过，范围“更大”的类型之间可以隐式转换：
```c++
int a = 5;
long long b = a;	// OK
```
但是，如果范围“变小”，就不行了：
```c++
long long x = 10LL;
int y = x;			// Error
```
这时，**如果你确定不会溢出（即数据范围在目标类型内）**，那么需要使用**强制类型转换**。
强制类型转换的语法很简单，只要像 `(目标类型) 原内容` 这样就可以，像这样：
```c++
long long x = 10LL;
int y = (int)x;		// OK
```

#### void*

接下来，我们需要认识一种奇怪的指针类型：`void*`。
其它的指针都是自己的类型加`*`，但唯独 `void` 这个类型是不存在的。（要等到C++17的 `any` 才有类似的东西，有兴趣的同学可以百度搜索）
这种指针的特殊之处在于，它可以接受任何类型的指针，但使用时必须强制类型转换，如下：
```c++
int a = 5;
void *p = &a;
cout << *((int*)p) << endl;
```
**注意，如果转换成了错误的类型，则会导致问题！**

##### void* 的用途

既然它可以接受任意类型的指针，那么它的用途便是表示“任何一种类型”。
如我们以后要用到的、设置一片内存空间的值的 `memset` 的使用方法：
```c++
void memset(void *ptr, int value, unsigned long long size);
// ptr: 空间
// value: 值
// size: 大小(unsigned 表示无符号，可以表示更大的范围)
```

------

好了，这期的内容就到这里。
下期预告：结构体与函数