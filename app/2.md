# C++ 快速入门
## 第 2 篇 - 变量与控制语句
### 变量
#### 概述
变量，用最简单（*也不太严谨*）的话说，就是用一个代号表示一个值（数值、字符串……）。不过，对应的值是可以变的。
既然值有类型，那么变量也会有**类型**。
本章的后续会详细讲解类型。
所以完整的**初始化语句**的像这样：
```
#include <string>	// C++ 的 string 类型需要这个头文件。
using namespace std;

int a = 5; // 既然是语句，就要加分号！
char b = 'a';
float c = 3.5;
double d = 1.1112;
string e = "Test";
bool f = true;
```
我们可以把它拆开看：
```

int    a     =             5 ;
//^    ^     ^             ^ ^
//类型 变量名 必不可少的等号 值 必不可少的分号

```
**(类型与变量名之间需要有空格。变量名与等号、等号与值、值与分号之间则不一定。可以有空格的地方，空格的个数没有限制。)**
#### 赋值
如果要重新往变量中赋值，例如，我们希望将 `a` 设置为 `10`，那么需要：
```
a = 10;
```
那么，`a` 就变成 `10` 了。
同理，上面的 `b`, `c`, `d` 等等都可以这样。
**但还是要注意类型要一致，否则可能会产生以外结果或报错 （*以后你会了解到*）!**
#### 定义
如果我现在给出这样一些代码：
```

int main() { // 这就是我们上一节讲的主函数
	int a;
	return 0;
}

```
那么会怎么样呢？
请各位先花一点时间想一想、尝试一下。
如果没错的话，会正常地编译并运行程序。
有人可能会问：
*你刚刚说完整的语句是形如 `int i = 5`的，那么这里没有给定值，为什么也能行呢？*
这就要讲到**定义**和**赋值**的分离了。

------------

比如说
```
int a;
```
只是**定义**了变量 `a`，但是 `a` 的值是什么呢？我们现在还不知道（*毕竟还没有指定*）。它的值是不确定的。所以，只有定义再赋值的变量，我们才去正式使用它的值。
那定义有什么用呢？别急，后面讲解 `if` 的时候就会讲到。

------------


看到这里，显然你已经明白：
初始化 = 定义 + 赋值

#### 类型

各种事物都有自己的类型。显然，C++里的变量也有自己的类型。
比如上面提到的代码：
```
#include <string>
using namespace std;

int a = 5; // int: 整型
char b = 'a'; // char: 字符型
float c = 3.5; // float: 浮点数
double d = 1.1112; // double: 精度更高
string e = "Test"; // string: C++ 的字符串
					// 需要 include <string>
					// C 的字符串在以后有介绍
bool f = true;		// bool: 是 (true) 或否 (false)
```
同时，我们还有这些类型：
```
short v1;	// 短整型，用的很少
long v2;	// 长整型
			// 大部分情况下和 int 一致，
			// 和 long long 区分。
long long v3;
			// 这个就比 int 的范围大
```

值也有类型：
```
#include <string>
using namespace std;

int a = 5; // int: 整型 (数字也可以赋值给 char, short, long, long long, double, float)
char b = 'a'; // 'a': 字符型 (字符用单引号括起来，单个, 也可以赋值给 int, long, long long, double, float)
char b2 = '\n';	// '\' 进行转义，如果你忘记了，可以看上一篇
float c = 3.5; // float: 浮点数 (数字也可以赋值给 char, short, long, long long, double, float)
double d = 1.1112; // double: 精度更高
string e = "Test"; // string: C++ 的字符串 (以后细讲，我们先认为它只能赋给 string)
					// 需要 include <string>
					// C 的字符串在以后有介绍
bool f1 = true;		// bool: 是 (true) 或否 (false) (也可以赋值给 char, short, long, long long, double, float)
bool f2 = false;
```

##### 为什么区分 char, short, int, long 和 long long？
这些类型都能表示数字。但它们的范围有所不同：

| 类型 | 范围 |
| :---: | :---: |
|`char`|-128~127 或 0~255 (unsigned)|
|`short`|-32768~32767|
|`int`,`long`|-2,147,483,648~2,147,483,647|
|`long long`|-(2^64)~(2^64-1)|

这里还涉及到 `unsigned` 的问题，但这很少用到，我们以后再讲。

##### 奇怪的赋值增加了
刚才我们看到，我们甚至可以（或者*“好像可以”*）写下这样的语句：
```
int a = 'a';
int b = true;
int c = 4.4;
int d = 999999999999;
```

这里涉及到**类型转换**的问题。
一般地，在类型之间有这么几种转换方式：

*（以下的转换从行到列，如：）*

| 类型/类型 | A | B |
| :---: | :---: | :---: |
| A | / | A 到 B |
| B | B 到 A | / |

###### 表格

`x` 表示会引起**精度损失** (见下方)。
`*` 表示注释（见下方）。

| 类型/类型  | char  | short  | int  | long long  | float | double  | string  |  bool |
| :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: |
| **char**  | /  |   |   |   |   |   | \*1  | x  |
| **short** | x  | /  |   |   |   |   | \*2| x  |
| **int**  | x  | x  | /  |   |   |   | \*2  | x  |
| **long long**  | x  |  x | x  | /  |   |   | \*2  | x  |
| **float**  | x  | x  | x  | x  | /  |   | \*2  | x  |
| **double**  | x  | x  |  x | x  | x  | /  | \*2  | x  |
| **string**  | \*3  | \*3  | \*3  | \*3  | \*3  | \*3  |  / | \*3  |
| **bool**  | x  | x  |  x | x  |  x | x  | x  |  /  |

###### 注释
\*1 类型转换有所不同。
```
// string a = 'b';	// 不能这样
string a;
a = 'b';			// OK
```
\*2 需要使用 `to_string` 函数 *（函数会在以后讲解）*。方法如下：
```
int b = 10;
string a = to_string(b);
```
**(\* `to_string` 需要启用 C++11 标准。)**
\*3 不能使用标准的方式进行转换。需要使用 `atoi` 等函数*（函数会在以后讲解）*。

##### 精度损失
变量的转换有时可以成功，但会遇到精度损失。
精度损失有几种情况：

| 转换情况 | 行为 |
| :---: | :---: |
| bool, char, short, int, long long 转换 | 保留低二进制位 |
| float, double 转换 | 不确定 |

#### 运算
变量可以进行一些运算，运算的结果可以像值一样使用：
```
int a = 5, b = 3;
int c = a + b;			// c = 8
```
同理，其它类型的变量也可以进行运算。
以下是支持的运算：

`O` 表示支持。
`X` 表示不支持。

| 类型/运算 | + | - | * | / | % (取余) | 位运算 (^, ~, & 等等) |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| bool, char, short, int, long long *（可以互相混用）* | O | O | O | O | O | O |
| float, double*（可以互相混用）* | O | O | O | O | X | X |
| string | O\* | X | X | X | X | X

\* string 的 `+` 可以连接 2 个字符串。如 `"a" + "b"` 得到 `"ab"`。

------------



接下来，我们接下来进入另一个大板块：`if`。

### if-else if-else -- 条件跳转

我们先看这么一段程序；

```
#include <cstdio>
using namespace std;

int main() {
	int age = 14;	// (1)
	if (age >= 18)	// 这里的 ">=" 就是大于等于，后期会细讲
		printf("哦，你成年了\n");
	else
		printf("你还没成年\n");
	return 0;
}
```
运行结果应该会是：
![](http://steambird1.github.io/app/img10.jpg)
你也可以把 (1) 处的初始化改为 `20`，那么就会变成：
![](http://steambird1.github.io/app/img11.jpg)

因此，我们可以简单地发现 `if` 语句的使用：

```
if (/*条件*/) {
	// 条件满足时执行 ...
} else {
	// 条件不满足时执行 ...
}
```


------------

#### 更多判断？
假设我们有多个条件要判断（被2、3、5、7整除），那么我们怎么写呢？
如果这么写：
```
int a;
//输入等
if (a % 2 == 0) {		// % 是取余，== 是判断相等，以后会细讲
	//...
} else {
	if (a % 3 == 0) {
		// ...
	} else {
		if (a % 5 == 0) {
			// ...
		} // ...
	}
}
```
确实，这样也太丑了。
那么有没有其它的解决方案呢？有。
```
int a;
//输入等
if (a % 2 == 0) {
	// ...
} else if (a % 3 == 0) {
	// ...
} // ...
else {
	// 都不满足
}
```

这样，我们可以看到 `if` 语句的完整使用：

```
if (/* 条件 */) {
	// ...
} else if (/* 条件 */) {	// 如果上一个 if/else if 不满足才会判断
	// ...
} // ... 这里可以写无数个 else if
// 如果是 if 则无论上面的 if 是否满足都会执行
else {
	// 上方的 if、else if 都不满足时执行
}
```

#### 只需要判断数值？
我们看一个例子：
```
#include <cstdio>
using namespace std;

int main() {
	int n;
	scanf("%d",&n);		// 从窗口输入 1 个数，以后会细讲
	switch (n) {
		case 0:
			printf("执行操作 a\n");
			break;
		case 1:
			printf("执行操作 b\n");
		case 2:
			printf("执行操作 c\n");
			break;
		default:
			printf("执行其它\n");
			break;
	}
	return 0;
}
```
现在，让我们尝试输入不同的 `n` 值。
![](http://steambird1.github.io/app/img14.jpg)
可以看到，switch-case 语句的使用类似这样：
```
	switch (/* 值 */) {
		case /* 值 */: case /* 更多值 */:
			// 如果等于 case 中的内容，则执行此处代码
			break;		// 不再继续
						// 如果移除这行，则会继续执行下面的内容，不论是否满足下面的 case！
		case /* 其它值 */:
			// ...
			break;
		default:
			// 如果上方条件均不满足，则执行此处代码
	}
```
##### switch-case 中要注意的地方
- switch-case 代码内不能声明变量。
	- 思考：为什么？
- switch-case 中 switch 内只能使用 bool, char, short, int, long long, float, double.
- switch-case 中 case 内只能使用值，不能是变量。即，`case a:` 是错误的。
正因如此，switch-case 很少使用。但我们也应看到它的好处：它的时间复杂度是 `O(1)` *（多个 `if` 的时间复杂度是 `O(n)`，时间复杂度将在以后讲解）*

#### 只需要当作数值？
我们看一个片段：
```
int a,b;
// 对 b 的操作 ...
if (b == 0) {
	a = 1;
} else {
	a = 0;
}
```
有没有什么办法简化这个操作呢？
有：
```
int a,b;
// 对 b 的操作 ...
a = (b == 0) ? 1 : 0;
```
由此，我们可以发现运算符 `?:` 的使用：
` bool ? 满足的值 : 不满足的值 `
同时，我们也可以发现，`==` 也是一种运算符，它检查两个值是否相等，返回 `bool` 类型。所以，这样的代码也是可以的**（虽然我们一般不这么做）**：
```
int a,b,c;
// ...
c = (a == b);		// bool 转换到 int
```
和 `==` 相同的还有 `>`, `<`, `>=`, `<=` 等（看形状就知道是干什么的）。

#### 作用域
接下来我们看一个例子：
```
#include <cstdio>
using namespace std;

int main() {
	bool flag;
	int a,b;
	scanf("%d%d",&a,&b);	// 从窗口输入 2 个数，以后会细讲
	flag = true;
	if (a > b) {
		flag = false;
	}
	if (flag) {
		printf("a 更大!\n");
	} else {
		printf("a 相等或更小!\n");
	}
}
```
在这个例子中，你会注意到，我们在第 4 行只声明、并未赋值。但我们可以看到，这个变量在 `if` 语句块中被赋值。
因此，我们可以知道：
**以大括号为分割，大括号之外已声明的变量可以在大括号之内使用。它们的值同步改变。**
但如果将第 8 行的
```
flag = false;
```
改为
```
bool flag = false;
```
呢？
我们尝试运行一下：
![](http://steambird1.github.io/app/img12.jpg)
可以看到，无论输入的 `a` 与 `b` 如何，`flag` 都为 `true`。
因此，我们又可以知道：
**若大括号内重新声明了相同名称的变量，则这个变量在该大括号内会覆盖之前的变量，大括号外不受影响。**
正因如此，我们需要使用声明。

#### if 语句内关系判断的拓展
我们看这样一个程序：
```
#include <cstdio>
using namespace std;

int main() {
	int a;
	scanf("%d",&a);
	if (a) {
		printf("OK\n");
	} else {
		printf("NO\n");
	}
	return 0;
}
```
现在，让我们尝试输入不同的 `a` 值。
我们再尝试运行一下。
![](http://steambird1.github.io/app/img13.jpg)
可以看到，当我们输入非 `0` 值时，`if` 条件始终成立。
因此，我们可以发现：**`if` 语句将条件判断部分转换为 `bool` **。


------------

### 调试
有时我们可能会遇到程序能通过编译，但在运行时出现问题，例如：
- 程序没有像预期一样执行
	- 陷入死循环
	- 出现运行错误
- 变量的值有问题
这些问题，就可以通过**调试**找到出现问题的地方。
例如这个程序，找到几个数中的最大值：

```
#include <cstdio>
using namespace std;

int main() {
	int n,x,max;
	scanf("%d",&n);					// 你可以认为这是输入 n
	for (int i = 0; i < n; i++) {	// 你可以认为这句话的意思是将里面的语句块执行 n 次 （for 循环以后会讲解） 
		scanf("%d",&x);				// 你可以认为这是输入 x
		if (x > max) {
			max = x;
		}
	}
	printf("%d\n",max);				// 你可以认为这是输出 max 
	return 0;
}
```
看起来似乎没有什么问题。
但当我们输入负数时，问题出现了：
![](http://steambird1.github.io/app/img15.jpg)
这时，我们就可以使用"调试"。
点击这个按钮，进入"调试"：
![](http://steambird1.github.io/app/img16.jpg)

------------


**注意，如果进入这个界面：
![](http://steambird1.github.io/app/img17.jpg)
则需要先点击'No',再点击'调试'面版中的'停止执行',
![](http://steambird1.github.io/app/img18.jpg)
然后进入 '工具'->'编译选项'->'连接器'->'产生调试信息' 并改为 Yes,
![](http://steambird1.github.io/app/img19.jpg)
之后点击 '全部重新编译',
![](http://steambird1.github.io/app/img1a.jpg)
方可再次调试。**

------------

#### 别急！
调试前，我们还需要做一些准备——设置**断点**。
有时，我们不需要一条条执行语句，我们便可以设置断点，在那里停下来。
要设置断点，只要在行号前点击即可。（如果你不确定在哪里断开，那么在**第一个输入/输出语句（例如scanf、printf等函数的地方，以后会详细讲解）**）
设置好的断点应该像这样：
![](http://steambird1.github.io/app/img1b.jpg)
然后，我们点击之前所说的调试，就可以开始了。

#### 开始调试

这时，我们可以看到，程序暂停了：
![](http://steambird1.github.io/app/img1c.jpg)
我们点击下方调试面板的“下一步”，便可以在原来的程序窗口输入值。这时，程序会等待我们输入一个值*（以后会细讲）*。

按键盘上的回车*(Enter)*，`scanf` 便得到了这个数，程序开始执行下一条语句。这时我们可以看到，正在执行的行的位置发生了变化**（蓝色即为正在执行的行）**：
![](http://steambird1.github.io/app/img1d.jpg)

#### 变量的查看

当然，在调试过程中，我们还关心各个变量的值。
有 2 种方法可以查看变量的值：
- 将鼠标移到变量上，如图：
  ![](http://steambird1.github.io/app/img1e.jpg)
- 使用左侧的“调试”。
接下来，我们将重点介绍第二种方式。

--------------------

点击下方调试面板的“添加查看”，再输入变量名，便可以查看该变量的值。如：
![](http://steambird1.github.io/app/img1f.jpg)
这些变量的值会自动刷新。右键它们还可以删除查看。


------------

#### 回到正题
现在，让我们正式开始调试之前提出的问题程序。
我们尝试输入几个负数：
![](http://steambird1.github.io/app/img1g.jpg)

仔细看，发现问题出在哪了吗？
对！`max` 没有进行初始化，默认值是 `0` **（实际上不一定哦！）**

再想想，我们怎么改进？
你应该可以想到，我们必须使第一个数一定能大于 `max`。因此，我们可以将 `max` 设置为一个极小值。
*（忘记极小值怎么设？往前翻，去看**int 类型的范围**。）*

现在，我们算是解决了问题。

#### 语句遇到调试

显然，在现在这个状态下，`if` 语句内的块不会被执行。
因此，当我们点击“下一步“时，`if` 语句会被跳过。

![](http://steambird1.github.io/app/img1h.jpg)

可是，看到这张图，你可能会问：为什么调试的箭头直接跳到了 `for` 循环的开头呢？

答案是：在这个程序里，`if` 语句结束，也到达 `for` 的结束，因此重新开始一轮循环。


------------

那么，今天的内容就到这里了。
注：由于期中考试等等原因，下一篇**最早** 2 周后才会发布；另外这种东西的篇幅真的很长，所以延期也不一定*（尽量不延很久吧。）*

另外不要忘记在学完这些内容之后练习一下。

如，写一个最简单的 A+B Problem （[洛谷 A+B Problem](https://www.luogu.com.cn/problem/P1001 "洛谷 A+B Problem") （请自行注册洛谷账户，*洛谷是个有意思的平台*）或 [文海信奥社团 A+B Problem](http://47.96.116.66/problem.php?id=1000 "文海信奥社团 A+B Problem")（需要有社团账号））。
- 提示：用 `printf("%d",n)` 输出一个 `int` 类型的 `n` 。（你也可以将 `n` 替换成返回 `int` 结果的内容。）